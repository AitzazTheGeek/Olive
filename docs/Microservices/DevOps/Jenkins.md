# Continious Integration
`Continious Delivery` and `DevOps` have many well known operational benefits for the process of software development and management. But they are even more vital in a Microservice-oriented architecture. Why? Because with Microservices, you will typically have `10s of deployments per day`, after every small bug fix, or new feature. That makes it impossible to go about it manually.

`Continious deployment` enables us to rapidly deploy changes without the risk of `human errors`. Once designed and tested, you can trust the deployment process way more than any developer, even the most experienced ones.

Also, `scripting the deployment process` is a form of `documenting` it, that enables anybody to learn and do the process easily.


## Jenkins
There are many tools out there for deployment automation but we have chosen `Jenkins` because:

- It is one of the most popular tools, which means there is a good community support for it.
- It is open source, so we don't have to pay for anything.
- It has a rich library of plugins for different build and deployment tasks.

Our build process has a fairly complex structure and chosing Jenkins has been nothing but benefitial for us (hopefully it will remain that way). 

For our microservices commonly use the same technology stack (.net core, MS SQL) and developed by [M#](http://learn.msharp.co.uk/#/Overview/README); However, we are not limited to use .net core or M#. You may choose whatever tech stack you need but the build process has to be adjusted for the new stack.

### Jenkins Job
The first step to set up CI/CD in Jenkins we need to first create a `job`. There are different types of jobs in Jenkins but becaue of our complex build process we needed a good level of customizability, which `Pipeline` jobs offer. Apart form being able to script the build process, pipeline jobs offer stages, which can be used to split different build steps for better organization. Jenkins provides a very good presentation for different stages and their time elapsed.


## Build Steps

### Msharp
If you have worked with M# or reviewed the link provided above you should know how it works. If you don't however, below is a short summary of how Msharp generates a project.

Each Msharp application has four projects. Two, `Model` and `UI`, used to define the metadata and structured used by MSharp to generate the application. The other two, `Domain` and `Website`, generated by Msharp using the metadata defined in Model and UI. After defining the application structure in Model and UI, you first need to build them using dotnet CLI, or in visual studio. There is a post-build-event defined in those two projects that run after they are built (duh!), which genrate the Domain and Website projects; However, there is a build sequence, provided below, you need to follow to generate the application property. 
* Model
* Domain
* UI
* Website

Because the UI project has to know what entities has been defined in the application it has a dependency to Domain. Once the Domain project is built, any changes to the entity structure - a new entity, new properties etc - made in Model will be visible to UI. The build process obviously 

### step 1






## Build Servers
### Preparing the server
### TODO 
...
